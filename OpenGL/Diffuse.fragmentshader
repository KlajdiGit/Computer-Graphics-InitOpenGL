#version 330

in vec3 retNormal;
in vec2 retTexCoord;
in vec3 retFragPos;
in vec3 retViewDirection;

out vec4 FragColor;

struct Material
{
   float specularStrength;
   sampler2D diffuseTexture;
   sampler2D specularTexture;
};

struct Light
{
    vec3 position;
    vec3 color;
    vec3 ambientColor;
    vec3 diffuseColor;
    vec3 specularColor;

 /* float constant;
    float linear;
    float quadratic;

    vec3 direction;
    float coneAngle;
    float falloff; */
};

uniform float rComponent;
uniform float gComponent;
uniform float bComponent;
uniform float specStrengthColor;

uniform Material material;
#define NR_LIGHTS 1
uniform Light light[NR_LIGHTS];

void main()
{

   // Early out we have no color at this fragment position
   vec4 diffColor = texture(material.diffuseTexture, retTexCoord);
   if(texture(material.diffuseTexture, retTexCoord).a == 0)
   {
      discard;
   }

   vec3 finalColor = vec3(0);
   for(int i = 0; i < NR_LIGHTS; i++)
   {

      vec3 lightDir = normalize(light[i].position - retFragPos); // Normalize, for correct dot products results
      float lambertianStrength = dot(lightDir, retNormal); //Add lambertion lighting
      vec3 refl = reflect(-lightDir, retNormal);
      //float specularStrength = pow(max(dot(retViewDirection, refl), 0.0f), material.specularStrength); 
        
      vec3 ambient = texture(material.diffuseTexture, retTexCoord).rgb * light[i].ambientColor / NR_LIGHTS;
      vec3 lambertian = lambertianStrength * texture(material.diffuseTexture, retTexCoord).rgb * light[i].diffuseColor;
     
      vec3 specularColor = vec3(rComponent, gComponent, bComponent);
      float specularStrength = pow(max(dot(retViewDirection, refl), 0.0f), specStrengthColor); 


      vec3 specular = specularStrength * specularColor * texture(material.specularTexture, retTexCoord).rgb * light[i].specularColor;

      finalColor += ambient + lambertian + specular; //Calculate final color 
   }

   FragColor = vec4(finalColor, diffColor.a);
}